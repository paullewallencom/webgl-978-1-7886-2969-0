<html>
<head>
  <title>Real-Time 3D Graphics with WebGL2</title>
  <link rel="shortcut icon" type="image/png" href="/common/images/favicon.png" />

  <!-- libraries -->
  <link rel="stylesheet" href="/common/lib/normalize.css">
  <script type="text/javascript" src="/common/lib/dat.gui.js"></script>
  <script type="text/javascript" src="/common/lib/gl-matrix.js"></script>

  <!-- modules -->
  <script type="text/javascript" src="/common/js/utils.js"></script>
  <script type="text/javascript" src="/common/js/EventEmitter.js"></script>
  <script type="text/javascript" src="/common/js/Camera.js"></script>
  <script type="text/javascript" src="/common/js/Clock.js"></script>
  <script type="text/javascript" src="/common/js/Controls.js"></script>
  <script type="text/javascript" src="/common/js/Floor.js"></script>
  <script type="text/javascript" src="/common/js/Light.js"></script>
  <script type="text/javascript" src="/common/js/Picker.js"></script>
  <script type="text/javascript" src="/common/js/Program.js"></script>
  <script type="text/javascript" src="/common/js/PostProcess.js"></script>
  <script type="text/javascript" src="/common/js/Scene.js"></script>
  <script type="text/javascript" src="/common/js/Texture.js"></script>
  <script type="text/javascript" src="/common/js/Transforms.js"></script>

  <script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    precision mediump float;

    in vec2 aVertexPosition;
    in vec2 aVertexTextureCoords;

    out vec2 vTextureCoords;

    void main(void) {
      vTextureCoords = aVertexTextureCoords;
      gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    }
  </script>

  <!-- For reference: http://glsl.heroku.com/e#1686.0 -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;

    uniform float uTime;
    uniform vec2 uInverseTextureSize;

    out vec4 fragColor;

    // ro is the ray origin
    // rd is the ray direction
    // s is the sphere
    float sphereIntersection(vec3 ro, vec3 rd, vec4 s) {
      // Transform the ray into object space
      vec3 oro = ro - s.xyz;

      float a = dot(rd, rd);
      float b = 2.0 * dot(oro, rd);
      // w is the sphere radius
      float c = dot(oro, oro) - s.w * s.w;

      float d = b * b - 4.0 * a * c;

      // No intersection
      if (d < 0.0) return d;

      return (-b - sqrt(d)) / 2.0;
    }

    vec3 sphereNormaml(vec3 pt, vec4 s) {
      return (pt - s.xyz) / s.w;
    }

    vec3 lightDirection = normalize(vec3(0.5));
    vec3 eyePos = vec3(0.0, 1.0, 4.0);
    vec3 backgroundColor = vec3(0.2);
    vec3 ambient = vec3(0.05, 0.1, 0.1);

    vec4 sphere = vec4(1.0);
    vec3 sphereColor = vec3(0.9, 0.8, 0.6);
    float maxDistance = 1024.0;

    float intersect(vec3 ro, vec3 rd, out vec3 norm, out vec3 color) {
      float distance = maxDistance;

      // If we wanted multiple objects in the scene you would loop through them here
      // and return the normal and color with the closest intersection point (lowest distance).
      float intersectionDistance = sphereIntersection(ro, rd, sphere);

      if (intersectionDistance > 0.0 && intersectionDistance < distance) {
        distance = intersectionDistance;
        // Point of intersection
        vec3 pt = ro + distance * rd;
        // Get normal for that point
        norm = sphereNormaml(pt, sphere);
        // Get color for the sphere
        color = sphereColor;
      }

      return distance;
    }


    void main(void) {
      // Wiggle the sphere back and forth a bit
      sphere.x = 1.5 * sin(uTime);
      sphere.z = 0.5 * cos(uTime * 3.0);

      // Pixel coordinate of the fragment being rendered
      vec2 uv = gl_FragCoord.xy * uInverseTextureSize;
      float aspectRatio = uInverseTextureSize.y / uInverseTextureSize.x;

      // Cast a ray out from the eye position into the scene
      vec3 ro = eyePos;

      // The ray we cast is tilted slightly downward to give a better view of the scene
      vec3 rd = normalize(vec3(-0.5 + uv * vec2(aspectRatio, 1.0), -1.0));

      // Default color if we don't intersect with anything
      vec3 rayColor = backgroundColor;

      // See if the ray intersects with any objects.
      // Provides the normal of the nearest intersection point and color
      vec3 objectNormal, objectColor;
      float t = intersect(ro, rd, objectNormal, objectColor);

      if (t < maxDistance) {
        // Diffuse factor
        float diffuse = clamp(dot(objectNormal, lightDirection), 0.0, 1.0);
        rayColor = objectColor * diffuse + ambient;
      }

      fragColor = vec4(rayColor, 1.0);
    }
  </script>

  <script type="text/javascript">
    'use strict';

    let gl, clock, post;

    function configure() {
      const canvas = utils.getCanvas('webgl-canvas');
      utils.autoResizeCanvas(canvas);

      gl = utils.getGLContext(canvas);
      gl.clearColor(0.2, 0.2, 0.2, 1.0);
      gl.clearDepth(100);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      const program = new Program(gl, 'vertex-shader', 'fragment-shader');

      clock = new Clock();
      new Scene(gl, program);

      const camera = new Camera(Camera.ORBITING_TYPE);
      camera.goHome([0, 0, 40]);
      camera.setFocus([0, 0, 0]);
      camera.setElevation(-40);
      camera.setAzimuth(-30);
      new Controls(camera, canvas);

      new Transforms(gl, program, camera, canvas);

      post = new PostProcess(canvas, 'vertex-shader', 'fragment-shader');
    }

    function draw() {
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Checks to see if the framebuffer needs to be re-sized to match the canvas
      post.validateSize();
      post.bind();

      // Render the full-screen quad
      post.draw();
    }

    function init() {
      configure();
      clock.on('tick', draw);
    }

    window.onload = init;
  </script>
</head>

<body>

  <canvas id="webgl-canvas">
    Your browser does not support the HTML5 canvas element.
  </canvas>

</body>
</html>